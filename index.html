<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-64.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.ico">
  <link rel="mask-icon" href="/images/favicon-64.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":true},
    path: 'search.xml',
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":null}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="记录生活的点点滴滴">
<meta name="keywords" content="编程 发呆">
<meta property="og:type" content="website">
<meta property="og:title" content="nonlee - 工作经验分享">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="nonlee - 工作经验分享">
<meta property="og:description" content="记录生活的点点滴滴">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>nonlee - 工作经验分享</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
<!--    <span class="site-title">nonlee - 工作经验分享</span> -->
        <span class="site-title">nonlee.com</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%80%EF%BC%9A%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/">
    
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ljxhb@126.com">
      <meta itemprop="description" content="记录生活的点点滴滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nonlee - 工作经验分享">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%80%EF%BC%9A%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/" class="post-title-link" itemprop="url">汇编语言入门一：环境准备</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-25 20:55:23" itemprop="dateCreated datePublished" datetime="2019-10-25T20:55:23+08:00">2019-10-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">汇编语言</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%80%EF%BC%9A%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/" class="post-meta-item leancloud_visitors" data-flag-title="汇编语言入门一：环境准备" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%80%EF%BC%9A%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%80%EF%BC%9A%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zhuanlan.zhihu.com/p/23618489" target="_blank" rel="noopener" title="原文链接">原文链接</a></p>
<p>现阶段，找个方便好使的编程环境还是比较蛋疼的，对于部分想过瘾或者想从学习实践中学习的小伙伴来说，略显蛋疼。不过，仔细琢磨，还是能够自己折腾出一个好用的环境来的。开搞。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%80%EF%BC%9A%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%BA%8C%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%9C%89%E4%BA%86%E5%85%88%E8%BF%87%E6%8A%8A%E7%98%BE/">
    
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ljxhb@126.com">
      <meta itemprop="description" content="记录生活的点点滴滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nonlee - 工作经验分享">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%BA%8C%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%9C%89%E4%BA%86%E5%85%88%E8%BF%87%E6%8A%8A%E7%98%BE/" class="post-title-link" itemprop="url">汇编语言入门二：环境有了先过把瘾</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-25 21:55:23" itemprop="dateCreated datePublished" datetime="2019-10-25T21:55:23+08:00">2019-10-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">汇编语言</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%BA%8C%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%9C%89%E4%BA%86%E5%85%88%E8%BF%87%E6%8A%8A%E7%98%BE/" class="post-meta-item leancloud_visitors" data-flag-title="汇编语言入门二：环境有了先过把瘾" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%BA%8C%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%9C%89%E4%BA%86%E5%85%88%E8%BF%87%E6%8A%8A%E7%98%BE/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%BA%8C%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%9C%89%E4%BA%86%E5%85%88%E8%BF%87%E6%8A%8A%E7%98%BE/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zhuanlan.zhihu.com/p/23639191" target="_blank" rel="noopener" title="原文链接">原文链接</a></p>
<p>上回说到，咱们把环境搭好了，可以开始玩耍汇编了。</p>
<h3 id="寄存器是啥玩意儿？"><a href="#寄存器是啥玩意儿？" class="headerlink" title="寄存器是啥玩意儿？"></a>寄存器是啥玩意儿？</h3><p>开始学C的时候，有没有一种感觉，变量？类型？我可是要改变世界的男人，怎么就成天在跟i++较劲啊？这黑框程序还只能用来算数学，跟说好的不一样呢？？？想必后来，见得多了，你的想法也不那么幼稚了吧。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%BA%8C%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%9C%89%E4%BA%86%E5%85%88%E8%BF%87%E6%8A%8A%E7%98%BE/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%89%EF%BC%9A%E6%98%AF%E6%97%B6%E5%80%99%E4%B8%8A%E5%86%85%E5%AD%98%E4%BA%86/">
    
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ljxhb@126.com">
      <meta itemprop="description" content="记录生活的点点滴滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nonlee - 工作经验分享">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%89%EF%BC%9A%E6%98%AF%E6%97%B6%E5%80%99%E4%B8%8A%E5%86%85%E5%AD%98%E4%BA%86/" class="post-title-link" itemprop="url">汇编语言入门三：是时候上内存了</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-25 22:08:54" itemprop="dateCreated datePublished" datetime="2019-10-25T22:08:54+08:00">2019-10-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">汇编语言</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%89%EF%BC%9A%E6%98%AF%E6%97%B6%E5%80%99%E4%B8%8A%E5%86%85%E5%AD%98%E4%BA%86/" class="post-meta-item leancloud_visitors" data-flag-title="汇编语言入门三：是时候上内存了" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%89%EF%BC%9A%E6%98%AF%E6%97%B6%E5%80%99%E4%B8%8A%E5%86%85%E5%AD%98%E4%BA%86/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%89%EF%BC%9A%E6%98%AF%E6%97%B6%E5%80%99%E4%B8%8A%E5%86%85%E5%AD%98%E4%BA%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zhuanlan.zhihu.com/p/23722940" target="_blank" rel="noopener" title="原文链接">原文链接</a></p>
<p>上回说到了寄存器和指令，这回说下内存访问。开始之前，先来复习一下。</p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>寄存器是在CPU里面<br>寄存器的存储空间很小<br>寄存器存放的是CPU马上要处理的数据或者刚处理出的结果（还是热乎的）</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/10/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%89%EF%BC%9A%E6%98%AF%E6%97%B6%E5%80%99%E4%B8%8A%E5%86%85%E5%AD%98%E4%BA%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%9B%9B%EF%BC%9A%E6%89%93%E9%80%9AC%E5%92%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">
    
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ljxhb@126.com">
      <meta itemprop="description" content="记录生活的点点滴滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nonlee - 工作经验分享">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%9B%9B%EF%BC%9A%E6%89%93%E9%80%9AC%E5%92%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">汇编语言入门四：打通C和汇编语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-31 23:17:09" itemprop="dateCreated datePublished" datetime="2019-10-31T23:17:09+08:00">2019-10-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">汇编语言</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%9B%9B%EF%BC%9A%E6%89%93%E9%80%9AC%E5%92%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" class="post-meta-item leancloud_visitors" data-flag-title="汇编语言入门四：打通C和汇编语言" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%9B%9B%EF%BC%9A%E6%89%93%E9%80%9AC%E5%92%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%9B%9B%EF%BC%9A%E6%89%93%E9%80%9AC%E5%92%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zhuanlan.zhihu.com/p/23779935" target="_blank" rel="noopener" title="原文链接">link</a></p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>上回我们把汇编里涉及到的寄存器和内存访问相关的内容说了。先来梳理一下：</p>
<p>寄存器是一些超级小的临时存储器，在CPU里面，存放CPU马上就要用到的数据或者刚处理完的结果<br>要处理的数据太多，寄存器装不下了，需要更多寄存器，但是这玩意贵啊<br>内存可以解决上述问题，但是内存相比寄存器要慢，优点是相对便宜，容量也大</p>
<h3 id="插曲：C语言与汇编语言的关系"><a href="#插曲：C语言与汇编语言的关系" class="headerlink" title="插曲：C语言与汇编语言的关系"></a>插曲：C语言与汇编语言的关系</h3><p>还有一些疑虑，先暂时解释一下。首先，C语言里编程里，我们从来没有关心过寄存器。汇编语言里突然冒出这么一个东西，学起来好难受。接下来的内容，我们先把C语言和汇编语言的知识，来一次大一统，帮助理解。</p>
<p>首先我们来看一个C语言程序：</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int <span class="symbol">x</span>, <span class="symbol">y</span>, z;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    <span class="symbol">x</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="symbol">y</span> = <span class="number">3</span>;</span><br><span class="line">    z = <span class="symbol">x</span> + <span class="symbol">y</span>;</span><br><span class="line">    <span class="keywords">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到我们的汇编教程才刚开始，我这里尽可能先简化C程序，这样稍后涉及到等价的汇编内容时所需的知识都是前面介绍过的。</p>
<p>保存为test01.c文件，先编译运行这个程序：</p>
<p>（注意，这里的gcc带了一个参数-m32，因为我们要编译出32位（x86）的可执行文件）</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>gcc -m32 test01.c -o test01</span><br><span class="line"><span class="variable">$ </span>./test01 ; echo <span class="variable">$?</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>好了，在这里，我们的程序返回了一个值：5。</p>
<p>好的，接下来我们看看如果我们要用汇编实现几乎相同的过程，该怎么做？</p>
<p>首先，三个全局变量：</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int <span class="symbol">x</span>, <span class="symbol">y</span>, z;</span><br></pre></td></tr></table></figure>


<p>总得有吧。（这里之所以会用全局变量，是考虑到局部变量相关的汇编知识还未介绍，先将就一下，后续再说局部变量的内容）</p>
<p>首先，在C语言里，你可以认为每个变量都会占用一定的内存空间，也就是说，这里的x、y、z分别都占用了一个“整型”也就是4字节的存储空间。</p>
<p>上次我们介绍过在汇编里面访问内存的知识，当然，我们也知道了怎么在数据区划出一定的空间，这次我们就照搬前面提及的方法：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="meta">section</span> .data</span><br><span class="line"></span><br><span class="line">x    <span class="built_in">dw</span>    <span class="number">0</span></span><br><span class="line">y    <span class="built_in">dw</span>    <span class="number">0</span></span><br><span class="line">z    <span class="built_in">dw</span>    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这个程序就等价于下面的C代码：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是现在有了三个全局变量，只是现在汇编程序什么都没做，仅仅返回了0而已。</p>
<p>这里的C代码和上述汇编代码从某种程度上来说，就是完全等价的。甚至，我们的C语言编译器就可以直接把C代码，翻译成上述的汇编代码，余下的工作交给nasm再编译一次，把汇编转化为可执行文件，就能够得到最后的程序了。当然，理论上可以这么做，实际上有的编译器也就是这么做的，只是人家生成的汇编格式不是nasm，而是其它的类型，但是道理都差不多。</p>
<p>也就是说，一个足够精简的C编译器，只需要能够把C代码翻译成汇编代码，剩下的交给汇编器完成，也就能实现完整的C语言编译器了，也就能得到最后的可执行文件了。实际上C编译器是完全可以这么做的，甚至有的就是这么做的。</p>
<p>好了，先不扯这些，我们先把前面的程序补充完整，达到和最前面的C代码等价为止。接下来，我们要关注这个：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x</span> = <span class="number">2</span><span class="comment">;</span></span><br><span class="line"><span class="attr">y</span> = <span class="number">3</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>也就是要把数字2和3，分别放到x和y对应的内存区域中去。很简单，我们可以这么做：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> [x], <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">mov</span> [y], <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>也就是先把2扔到寄存器eax中去，然后把eax中的内容放回到x对应的内存中。同理，y也这样处理。</p>
<p>好了，接下来的加法语句：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">z</span> = x + y<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>也可以做了：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [x]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebx</span>, [y]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">mov</span> [z], <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>好了，这段代码应该可以看懂吧，简单说一下思路：</p>
<p>把x和y对应的内存中的内容分别放到eax和ebx中去<br>进行形如eax = eax + ebx的加法，最终的和存放在eax中<br>再将eax中的内容存放到z对应的内存中去<br>最后，我们还有一个事情需要处理，也就是返回语句：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> z;</span><br></pre></td></tr></table></figure>

<p>这个也很好办，按照约定，eax中的值，就是函数的返回值：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [z]</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>整个程序就算完了，我们已经完整地将C代码的汇编语言等价形式写出来了，最终的代码是这样的：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">mov</span> [x], <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">3</span></span><br><span class="line">    <span class="keyword">mov</span> [y], <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, [x]</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, [y]</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">mov</span> [z], <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, [z]</span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">section</span> .data</span><br><span class="line">x       <span class="built_in">dw</span>      <span class="number">0</span></span><br><span class="line">y       <span class="built_in">dw</span>      <span class="number">0</span></span><br><span class="line">z       <span class="built_in">dw</span>      <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>来先保存成文件test02.asm，编译运行看看效果：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>nasm -f elf test02.asm -o test02.o </span><br><span class="line"><span class="variable">$ </span>gcc -m32 test02.o -o test02</span><br><span class="line"><span class="variable">$ </span>./test02 ; echo <span class="variable">$?</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>搞定。结果完全和前面的C代码一致。</p>
<h3 id="揭开C程序的庐山真面目"><a href="#揭开C程序的庐山真面目" class="headerlink" title="揭开C程序的庐山真面目"></a>揭开C程序的庐山真面目</h3><p>你以为自己YY出等价的汇编代码就完事儿了？图样，接下来我们继续用工具一探究竟，玩真的。</p>
<p>先说一下准备工作，首先有下面两个文件：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">test01</span><span class="selector-class">.c</span>  <span class="selector-tag">test02</span><span class="selector-class">.asm</span></span><br></pre></td></tr></table></figure>
<p>其中一个为上面提到的完整C代码，一个为上述完整的汇编代码。然后按照前面的指示，都编译成可执行文件，编译完成后是这样的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 test01<span class="selector-class">.c</span> -o test01</span><br><span class="line">$ nasm -f elf test02<span class="selector-class">.asm</span> -o test02.o</span><br><span class="line">$ gcc -m32 -fno-lto test02<span class="selector-class">.o</span> -o test02</span><br><span class="line">$ ls</span><br><span class="line">test01  test01<span class="selector-class">.c</span>  test02  test02<span class="selector-class">.asm</span>  test02.o</span><br></pre></td></tr></table></figure>

<p>（注意，要按照这里的编译命令来做）</p>
<p>其中的test01是C代码编译出来的，test02是汇编代码编译出来的。</p>
<h3 id="祭出gdb"><a href="#祭出gdb" class="headerlink" title="祭出gdb"></a>祭出gdb</h3><p>好，接下来有请我们的大将军gdb登场。</p>
<p>先来看看我们的C编译后的程序，反汇编之后是什么鬼样子：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb <span class="string">./test01</span></span><br></pre></td></tr></table></figure>

<p>然后输入命令查看反汇编代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set disassembly-flavor intel</span><br><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   <span class="number">0x080483ed</span> &lt;+<span class="number">0</span>&gt;: <span class="keyword">push</span>   <span class="built_in">ebp</span></span><br><span class="line">   <span class="number">0x080483ee</span> &lt;+<span class="number">1</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line">   <span class="number">0x080483f0</span> &lt;+<span class="number">3</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:<span class="number">0x804a024</span>,<span class="number">0x2</span></span><br><span class="line">   <span class="number">0x080483fa</span> &lt;+<span class="number">13</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:<span class="number">0x804a028</span>,<span class="number">0x3</span></span><br><span class="line">   <span class="number">0x08048404</span> &lt;+<span class="number">23</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:<span class="number">0x804a024</span></span><br><span class="line">   <span class="number">0x0804840a</span> &lt;+<span class="number">29</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">ds</span>:<span class="number">0x804a028</span></span><br><span class="line">   <span class="number">0x0804840f</span> &lt;+<span class="number">34</span>&gt;:    <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line">   <span class="number">0x08048411</span> &lt;+<span class="number">36</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ds</span>:<span class="number">0x804a020</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x08048416</span> &lt;+<span class="number">41</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">ds</span>:<span class="number">0x804a020</span></span><br><span class="line">   <span class="number">0x0804841b</span> &lt;+<span class="number">46</span>&gt;:    <span class="keyword">pop</span>    <span class="built_in">ebp</span></span><br><span class="line">   <span class="number">0x0804841c</span> &lt;+<span class="number">47</span>&gt;:    <span class="keyword">ret</span>    </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) quit</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>好，别急，先退出，我们再看看我们汇编程序的反汇编代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gdb ./test02</span><br><span class="line">(gdb) set disassembly-flavor intel</span><br><span class="line">(gdb) disas main</span><br><span class="line">   <span class="number">0x080483f0</span> &lt;+<span class="number">0</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x2</span></span><br><span class="line">   <span class="number">0x080483f5</span> &lt;+<span class="number">5</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">ds</span>:<span class="number">0x804a01c</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x080483fa</span> &lt;+<span class="number">10</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x3</span></span><br><span class="line">   <span class="number">0x080483ff</span> &lt;+<span class="number">15</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ds</span>:<span class="number">0x804a01e</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x08048404</span> &lt;+<span class="number">20</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">ds</span>:<span class="number">0x804a01c</span></span><br><span class="line">   <span class="number">0x08048409</span> &lt;+<span class="number">25</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:<span class="number">0x804a01e</span></span><br><span class="line">   <span class="number">0x0804840f</span> &lt;+<span class="number">31</span>&gt;:    <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">ebx</span></span><br><span class="line">   <span class="number">0x08048411</span> &lt;+<span class="number">33</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ds</span>:<span class="number">0x804a020</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x08048416</span> &lt;+<span class="number">38</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">ds</span>:<span class="number">0x804a020</span></span><br><span class="line">   <span class="number">0x0804841b</span> &lt;+<span class="number">43</span>&gt;:    <span class="keyword">ret</span>    </span><br><span class="line">   <span class="number">0x0804841c</span> &lt;+<span class="number">44</span>&gt;:    <span class="keyword">xchg</span>   <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">   <span class="number">0x0804841e</span> &lt;+<span class="number">46</span>&gt;:    <span class="keyword">xchg</span>   <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure>

<p>好了，我们都看到反汇编代码了。先来检查一下这里test02的反汇编代码，和我们写的汇编代码是不是一致的：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x080483f0</span> &lt;+<span class="number">0</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x2</span></span><br><span class="line"><span class="number">0x080483f5</span> &lt;+<span class="number">5</span>&gt;: <span class="keyword">mov</span>    <span class="built_in">ds</span>:<span class="number">0x804a01c</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="number">0x080483fa</span> &lt;+<span class="number">10</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x3</span></span><br><span class="line"><span class="number">0x080483ff</span> &lt;+<span class="number">15</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ds</span>:<span class="number">0x804a01e</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="number">0x08048404</span> &lt;+<span class="number">20</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">ds</span>:<span class="number">0x804a01c</span></span><br><span class="line"><span class="number">0x08048409</span> &lt;+<span class="number">25</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:<span class="number">0x804a01e</span></span><br><span class="line"><span class="number">0x0804840f</span> &lt;+<span class="number">31</span>&gt;:    <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">ebx</span></span><br><span class="line"><span class="number">0x08048411</span> &lt;+<span class="number">33</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ds</span>:<span class="number">0x804a020</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="number">0x08048416</span> &lt;+<span class="number">38</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">ds</span>:<span class="number">0x804a020</span></span><br><span class="line"><span class="number">0x0804841b</span> &lt;+<span class="number">43</span>&gt;:    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>直接和前面写的汇编进行比对便是，由于格式问题，里面的部分地址和标签已经面目全非，但是我们只要能够辨识出来就行了，不需要全部都搞得明明白白。这是前面的汇编代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> [x], <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">3</span></span><br><span class="line"><span class="keyword">mov</span> [y], <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [x]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebx</span>, [y]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line"><span class="keyword">mov</span> [z], <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, [z]</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>数一下行数就知道，是相同的。再仔细看看每一条指令，基本也是差不多的。当然x、y、z这些东西不见了，变成了一些奇奇怪怪的符号，在此暂不深究。</p>
<p>我们再看看C程序的汇编代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x080483ed</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   <span class="built_in">ebp</span></span><br><span class="line"><span class="number">0x080483ee</span> &lt;+<span class="number">1</span>&gt;:     <span class="keyword">mov</span>    <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line"><span class="number">0x080483f0</span> &lt;+<span class="number">3</span>&gt;:     <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:<span class="number">0x804a024</span>,<span class="number">0x2</span></span><br><span class="line"><span class="number">0x080483fa</span> &lt;+<span class="number">13</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:<span class="number">0x804a028</span>,<span class="number">0x3</span></span><br><span class="line"><span class="number">0x08048404</span> &lt;+<span class="number">23</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:<span class="number">0x804a024</span></span><br><span class="line"><span class="number">0x0804840a</span> &lt;+<span class="number">29</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">ds</span>:<span class="number">0x804a028</span></span><br><span class="line"><span class="number">0x0804840f</span> &lt;+<span class="number">34</span>&gt;:    <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="number">0x08048411</span> &lt;+<span class="number">36</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ds</span>:<span class="number">0x804a020</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="number">0x08048416</span> &lt;+<span class="number">41</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">ds</span>:<span class="number">0x804a020</span></span><br><span class="line"><span class="number">0x0804841b</span> &lt;+<span class="number">46</span>&gt;:    <span class="keyword">pop</span>    <span class="built_in">ebp</span></span><br><span class="line"><span class="number">0x0804841c</span> &lt;+<span class="number">47</span>&gt;:    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>这里，先撇开下面几个指令（这几个指令本身是有用的，但是在这个例子里，可以暂时先去掉，具体它们是干啥的，后面说），去掉它们：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ebp</span></span><br></pre></td></tr></table></figure>

<p>于是C程序反汇编变成了这样子：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x080483f0</span> &lt;+<span class="number">3</span>&gt;:     <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:<span class="number">0x804a024</span>,<span class="number">0x2</span></span><br><span class="line"><span class="number">0x080483fa</span> &lt;+<span class="number">13</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:<span class="number">0x804a028</span>,<span class="number">0x3</span></span><br><span class="line"><span class="number">0x08048404</span> &lt;+<span class="number">23</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="built_in">DWORD</span> <span class="built_in">PTR</span> <span class="built_in">ds</span>:<span class="number">0x804a024</span></span><br><span class="line"><span class="number">0x0804840a</span> &lt;+<span class="number">29</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">ds</span>:<span class="number">0x804a028</span></span><br><span class="line"><span class="number">0x0804840f</span> &lt;+<span class="number">34</span>&gt;:    <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="number">0x08048411</span> &lt;+<span class="number">36</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ds</span>:<span class="number">0x804a020</span>,<span class="built_in">eax</span></span><br><span class="line"><span class="number">0x08048416</span> &lt;+<span class="number">41</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">ds</span>:<span class="number">0x804a020</span></span><br><span class="line"><span class="number">0x0804841c</span> &lt;+<span class="number">47</span>&gt;:    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>还是看起来不太明朗，怎么办？我们追踪里面的数字2、3和add指令，把那些稀奇古怪的符号换成我们认识的标签x、y、z再看看：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x080483f0</span> &lt;+<span class="number">3</span>&gt;: <span class="keyword">mov</span>    [x],<span class="number">0x2</span></span><br><span class="line"><span class="number">0x080483fa</span> &lt;+<span class="number">13</span>&gt;:    <span class="keyword">mov</span>    [y],<span class="number">0x3</span></span><br><span class="line"><span class="number">0x08048404</span> &lt;+<span class="number">23</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">edx</span>,[x]</span><br><span class="line"><span class="number">0x0804840a</span> &lt;+<span class="number">29</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,[y]</span><br><span class="line"><span class="number">0x0804840f</span> &lt;+<span class="number">34</span>&gt;:    <span class="keyword">add</span>    <span class="built_in">eax</span>,<span class="built_in">edx</span></span><br><span class="line"><span class="number">0x08048411</span> &lt;+<span class="number">36</span>&gt;:    <span class="keyword">mov</span>    [z],<span class="built_in">eax</span></span><br><span class="line"><span class="number">0x08048416</span> &lt;+<span class="number">41</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,[z]</span><br><span class="line"><span class="number">0x0804841c</span> &lt;+<span class="number">47</span>&gt;:    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>对比前面我们自己写的汇编代码看看呢？是不是基本是八九不离十了？仅仅有两个地方不一样：1. 使用的寄存器顺序不太一样，但是这个无妨；2. 有两条汇编指令，在C编译后的反汇编代码中对应的是一条指令。</p>
<p>这里我们发现了，原来</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span> [x], <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

<p>可以被精简为一条语句：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov <span class="string">[x]</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>好的，按照C编译器给我们提供的信息，我们的汇编程序还可以简化成这样：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> [x], <span class="number">0x2</span></span><br><span class="line">    <span class="keyword">mov</span> [y], <span class="number">0x3</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, [x]</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, [y]</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">mov</span> [z], <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, [z]</span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">section</span> .data</span><br><span class="line">x       <span class="built_in">dw</span>      <span class="number">0</span></span><br><span class="line">y       <span class="built_in">dw</span>      <span class="number">0</span></span><br><span class="line">z       <span class="built_in">dw</span>      <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>然而，当我们把汇编写成这样自己编译的时候，却出错了，这里并不能完全这么写，得做一些小修改，把前两条指令改成：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> [x], <span class="number">0x2</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> [y], <span class="number">0x3</span></span><br></pre></td></tr></table></figure>

<p>这样再编译，就没有问题了。通过研究，我们用汇编写出了和前面的C程序编译后代码等价的汇编程序：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dword</span> [x], <span class="number">0x2</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dword</span> [y], <span class="number">0x3</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, [x]</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, [y]</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">mov</span> [z], <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, [z]</span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="meta">section</span> .data</span><br><span class="line">x       <span class="built_in">dw</span>      <span class="number">0</span></span><br><span class="line">y       <span class="built_in">dw</span>      <span class="number">0</span></span><br><span class="line">z       <span class="built_in">dw</span>      <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好了，到这里，我们通过nasm、gcc和gdb，将一个简单的C程序，用汇编语言等价地实现出来了。</p>
<p>说一下这一段内容的重点：</p>
<p>C程序在编译阶段，在逻辑上，会被转化成等价的汇编程序<br>汇编程序经过编译器内置（或外置）的汇编器，编译成机器指令（到可执行文件的过程中还有一个链接阶段，后面再提）<br>我们可以通过gdb反汇编得知一个C程序的汇编形式<br>其实，学习汇编语言的目的，并非主要是为了今后用汇编语言编程，而是借助于对汇编语言的理解，进一步地去理解高级语言在底层的一些细节，一个C语言的赋值语句，一个C语言的加法表达式，在编译后运行的时候，到底在做些什么。也就是通过汇编认识到计算机中，程序执行的时候到底在做些什么，CPU到底在干什么，借助于此，理解计算机程序在CPU眼里的本质。</p>
<p>后续通过这个，结合各种资料学习汇编语言，将是一个非常不错的选择。在对汇编进行实践和理解的过程中，也能更清楚地知道C语言里的各种写法，到底代表什么含义，加深对C语言的认识。</p>
<h3 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h3><p>本节内容涉及的代码和操作就多一些了，当然能够耐心做完是最好的，一天两天不够就三天五天，也是值得的。</p>
<p>文中若有疏漏，欢迎指正。</p>
<p>编辑于 2016-11-19</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%BA%94%EF%BC%9A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/">
    
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ljxhb@126.com">
      <meta itemprop="description" content="记录生活的点点滴滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nonlee - 工作经验分享">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%BA%94%EF%BC%9A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">汇编语言入门五：流程控制（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-31 23:05:55" itemprop="dateCreated datePublished" datetime="2019-10-31T23:05:55+08:00">2019-10-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">汇编语言</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%BA%94%EF%BC%9A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="汇编语言入门五：流程控制（一）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%BA%94%EF%BC%9A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%BA%94%EF%BC%9A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zhuanlan.zhihu.com/p/23845369" target="_blank" rel="noopener" title="原文链接">原文链接</a></p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>前面说到过这样几个内容：</p>
<p>几条简单的汇编指令<br>寄存器<br>内存访问<br>对应到C语言的学习过程中，无非就是这样几个内容：</p>
<p>超级简单的运算<br>变量<br>好了，到这里，我们继续接下来的话题，程序中的流程控制。</p>
<p>文中涉及一些汇编代码，建议读者自行编程，通过动手实践来加深对程序的理解。</p>
<h3 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h3><p>首先，最简单也最好理解的程序流程，便是从前往后的顺序执行。这个非常简单，还是举出前面的例子：</p>
<p>现在有1000个计算题：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">99</span>+<span class="number">10</span>=</span><br><span class="line"><span class="number">32</span><span class="number">-20</span>=</span><br><span class="line"><span class="number">14</span>+<span class="number">21</span>=</span><br><span class="line"><span class="number">47</span><span class="number">-9</span>=</span><br><span class="line"><span class="number">87</span>+<span class="number">3</span>=</span><br><span class="line"><span class="number">86</span><span class="number">-8</span>=</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>需要你一个个地从前往后计算，计算结果需要写在专门的答题卡上。当你每做完一个题，你需要继续做下一个题（这不是废话么）。</p>
<p>那么问题来了，我每次计算完一个题目，回头寻找下一个题目的时候，到底哪一个题是我接下来要计算的呢？</p>
<p>你可能会说：瞄一眼答题卡就知道了呀。这就尴尬了，计算机其实是比较傻的，它可没有“瞄一眼”这样的功能。</p>
<p>那这样的话，如果是自己做1000个题目，为了保证做题的时候每一个动作都不是多余的，有一个比较好的办法，就是强行在脑子里记住刚刚那个题目的位置。一会儿回头的时候，就立马知道该继续做哪个题了。</p>
<p>好了，那对于计算机来说呢？前面说到，你做计算题的时候临时留在脑子里的东西，就对应CPU里寄存器的数据。寄存器就充当了临时记住一些东西的功能。那么，在这里，CPU也是用的这个套路，在内部有一个寄存器，专门用来记录程序执行到哪里了。</p>
<h3 id="CPU中的顺序执行过程"><a href="#CPU中的顺序执行过程" class="headerlink" title="CPU中的顺序执行过程"></a>CPU中的顺序执行过程</h3><p>前面已经有了一个初步的结论，CPU里有一个寄存器专门存放“程序执行到哪里了”这样一个信息，而且这么做也是说得过去的，那就是：必须有一个东西记录当前程序执行到的位置，否则CPU执行完一条指令之后，就不知道接下来该干什么了。</p>
<p>在x86体系结构的CPU里面，这个执行位置的信息，是保存在叫做eip的寄存器中的。不过很遗憾，这个寄存器比较特殊，无法通过mov指令进行修改，也就是说，这么写mov eip, 0x233是行不通的。</p>
<p>（不要问我为什么，我也不知道，这都是人做出来的东西，支不支持就看人家的心情。反正Intel的CPU做出来就是这个样子的，你可以认为，Intel在做CPU的时候压根就没支持这个功能，他们觉得做了也没什么卵用。虽然你可能觉得有这个功能不是更好么，但是实际上，有时候刻意对功能施加一些限制，可以减少程序员写代码误操作的机会，eip这个东西，很关键）</p>
<p>好了，介绍完eip的作用之后，再说一下细节的东西。在执行一条指令的时候，eip此时代表的是下一条指令的位置，eip里保存的就是下一条指令在内存中的地址。这样，CPU在执行完成一条指令之后，就直接根据eip的值，取出下一条指令，同时还要修改eip，往eip上加一个指令的长度，让它继续指向后一条指令。</p>
<p>有了这样一个过程，CPU就能自动地去从前往后执行每一条指令了。而且，上述过程是在CPU中自动发生的，你写代码的时候根本不需要关心这个东西，只需要按照自己的思路从前往后写就是了。</p>
<p>好了，这一段更多的是讲故事，明白CPU里面有个eip寄存器，它的功能很专一，就是用来表示程序现在执行到哪儿了。说得精确一点，eip一直都指向下一个要执行的指令，这一点是由CPU自己保证的。总之，只要CPU没坏，它就能给你保证eip的精确。</p>
<h3 id="事情没那么简单"><a href="#事情没那么简单" class="headerlink" title="事情没那么简单"></a>事情没那么简单</h3><p>前面说了eip能记住程序执行的位置，那么CPU就能顺溜溜地一路走下去了。然而，世界并不是这么美好。因为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">( a &lt; <span class="number">1</span> )</span></span>&#123;</span><br><span class="line">    <span class="comment">// some code ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>( <span class="selector-tag">a</span> &gt;= <span class="number">10</span> ) &#123;</span><br><span class="line">    <span class="comment">// yi xie dai ma ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上有时候我们需要程序有一定的流程控制能力。就是有时候它不是老老实实按照顺序来执行的，中间可能会跳过一些代码，比如上述C代码中的a的值为100的时候。</p>
<p>那么这时候怎么搞呢？照这样说，程序就得具备“修改eip”的能力了，可是前面说了，mov指令不顶用啊？</p>
<p>放心，那帮做CPU的人没那么傻，他们早就想好了怎么办了。他们在设计CPU的时候是这么考虑的：</p>
<p>更改eip和更改别的寄存器产生的效果不一样，所以应该特殊对待<br>要更改有着特殊用途的eip，就用特殊的指令来完成，虽然都是在更改寄存器，但是代码写出来，表达给人的意思就不一样了<br>首先，我们需要更改eip来实现程序突然跳转的效果，进而灵活地对程序的流程进行控制。这里不得不祭出一套新的指令了：跳转指令。</p>
<p>不说了，铺垫也都差不多了，还是直接上代码，直观体验一把，然后再扯别的。先来一份正常的代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>如果前面好好学习的话，对这个一定不陌生。还是大致解释一下吧：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eax</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">ebx</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">eax</span> = eax + ebx</span><br></pre></td></tr></table></figure>

<p>所以，按照正常逻辑理解，最后eax为3，整个程序退出时会返回3。</p>
<p>好的，到这里，我们来引入新的指令，通过前后对比的变化，来理解新的指令的作用：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">jmp</span> gun_kai</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line"><span class="symbol">gun_kai:</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>这段代码相比前面的代码，多了两行：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    jmp gun_kai</span><br><span class="line">...</span><br><span class="line">gun_kai:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>好了，这段代码其实没什么功能，存粹是为了演示，运行这个代码，得到的返回结果为1。</p>
<p>好了，最后的结果告诉我们，中间的那一条指令：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br></pre></td></tr></table></figure>

<p>根本就没有执行，所以最后eax的值就是1，整个程序的返回值就是1。</p>
<p>好了，这里也没什么需要解释的，动手做，稍微对比分析一下就能够知道结论了。程序中出现了一条新的指令jmp，这是一个跳转指令，不解释。这里直接用一个等价的C语言来说明上述功能吧：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">int</span> <span class="string">main() &#123;</span></span><br><span class="line">    <span class="attr">int</span> <span class="string">a = 1;</span></span><br><span class="line">    <span class="attr">int</span> <span class="string">b = 2;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">goto</span> <span class="string">gun_kai;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">a</span> = <span class="string">a + b;</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">gun_kai</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">return</span> <span class="string">a;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>

<p>实际上，C语言中的goto语句，在编译后就是一条jmp指令。它的功能就是直接跳转到某个地方，你可以往前跳转也可以往后跳转，跳转的目标就是jmp后面的标签，这个标签在经过编译之后，会被处理成一个地址，实际上就是在往某个地址处跳转，而jmp在CPU内部发生的作用就是修改eip，让它突然变成另外一个值，然后CPU就乖乖地跳转过去执行别的地方的代码了。</p>
<h3 id="这玩意有啥用？"><a href="#这玩意有啥用？" class="headerlink" title="这玩意有啥用？"></a>这玩意有啥用？</h3><p>不对啊，这跳转指令能用来干啥？反正代码都直接被跳过去了，那我编程的时候干脆直接不写那几条指令不就得了么？使用跳转指令是不是有种脱了裤子放屁的感觉？</p>
<p>并不是，继续。</p>
<h3 id="if在汇编里的样子"><a href="#if在汇编里的样子" class="headerlink" title="if在汇编里的样子"></a>if在汇编里的样子</h3><p>前面说到了跳转，但是仿佛没卵用的样子。接下来我们说这样一个C语言程序：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">if</span>( a &gt; <span class="number">10</span> ) &#123;</span><br><span class="line">        a = a - <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序，最后的返回值是40，这没什么好解释的。那对应的汇编程序呢？其实也非常简单，先直接给出代码再分析：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">50</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">10</span>                         <span class="comment">; 对eax和10进行比较</span></span><br><span class="line">    <span class="keyword">jle</span> xiaoyu_dengyu_shi            <span class="comment">; 小于或等于的时候跳转</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">10</span></span><br><span class="line"><span class="symbol">xiaoyu_dengyu_shi:</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>这段汇编代码很关键的地方就在于这两条陌生的指令：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp eax, <span class="number">10</span>                         <span class="comment">; 对eax和10进行比较</span></span><br><span class="line"><span class="keyword">jle </span>xiaoyu_dengyu_shi            <span class="comment">; 小于或等于的时候跳转</span></span><br></pre></td></tr></table></figure>

<p>先细细解释一下：</p>
<p>第一条，cmp指令，专门用来对两个数进行比较<br>第二条，条件跳转指令，当前面的比较结果为“小于或等于”的时候就跳转，否则不跳转<br>到这里，至少上面这个程序，每一条指令都是很清楚的。只是你关心的是下面的问题：</p>
<p>我会写a &gt; 10的情况了，那么a &lt; 10怎么办呢？a == 10怎么办呢？a &lt;= 10怎么办呢？a &gt;= 10怎么办呢？<br>凉拌炒鸡蛋。</p>
<p>别急，先说套路。上面的C语言代码是这样的：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a &gt; <span class="number">10</span> ) &#123;</span><br><span class="line">    a = a - <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是表示：“比较a和10，a大于10的时候，进入if块中执行减法”</p>
<p>而汇编代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">10</span></span><br><span class="line">    <span class="keyword">jle</span> xiaoyu_dengyu_shi</span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">10</span></span><br><span class="line"><span class="symbol">xiaoyu_dengyu_shi:</span></span><br></pre></td></tr></table></figure>

<p>表示的是：“比较eax和10，eax小于等于10的时候，跳过中间的减法”</p>
<p>注意这里最关键的两个表述：</p>
<p>C语言中：a大于10的时候，进入if块中执行减法<br>汇编语言中：eax小于等于10的时候，跳过中间的减法<br>C语言和汇编语言中的条件判断，其组织的思路是刚好相反的。这就在编程的时候带来一些思考上的困难，不过这都还是小事情，实在困难你可以先画出流程图，然后对流程图进行改造，就可以了。</p>
<p>有了上面if的套路，接下来趁热打铁，再做一个练习：</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int ma<span class="meta">in(</span>) &#123;</span><br><span class="line">    int <span class="meta">x</span> = 1;</span><br><span class="line">    <span class="meta">if</span> ( <span class="meta">x</span> &gt; 100 ) &#123;</span><br><span class="line">        <span class="meta">x</span> = <span class="meta">x</span> - 20;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">x</span> = <span class="meta">x</span> + 1;</span><br><span class="line">    <span class="meta">return</span> <span class="meta">x</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这里按照前面的思路，在汇编语言里面，关键就是下面几点：</p>
<p>对x对应的东西与100进行比较<br>何时跳过if块中的减法<br>x = x + 1是无论如何都会执行的<br>按照前面的代码，稍作类比，很容易地就能写出下面的代码来：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">100</span></span><br><span class="line">    <span class="keyword">jle</span> xiao_deng_yu_100</span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">20</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">xiao_deng_yu_100:</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>把程序结合着前面的C代码进行对比，参考前面说的if在汇编里组织的套路，这个程序就很容易理解了。你还可以尝试把</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>更改为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">110</span></span><br></pre></td></tr></table></figure>

<p>试试程序的执行逻辑是不是发生了变化？</p>
<h3 id="再来套路"><a href="#再来套路" class="headerlink" title="再来套路"></a>再来套路</h3><p>前面说到了if在汇编中的组织方式，接下来，问题就更加复杂了：</p>
<p>我会写a &gt; 10的情况了，那么a &lt; 10怎么办呢？a == 10怎么办呢？a &lt;= 10怎么办呢？a &gt;= 10怎么办呢？<br>凉拌炒鸡蛋。</p>
<p>前面实际上只提到了两个流程控制相关的指令：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span></span><br><span class="line"><span class="keyword">jle</span></span><br></pre></td></tr></table></figure>

<p>以及一个比较指令：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cmp</span></span><br></pre></td></tr></table></figure>

<p>专门用来对两个操作数进行比较。</p>
<p>先从这里入手，总结套路。首先，这两条跳转指令是人想出来的，所以，你很容易想到，仅仅是这两条跳转指令好像还不够。其实，人家做CPU的人早也就想到了。所以，还有这样一些跳转指令：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ja </span>大于时跳转</span><br><span class="line"><span class="keyword">jae </span>大于等于</span><br><span class="line"><span class="keyword">jb </span>小于</span><br><span class="line"><span class="keyword">jbe </span>小于等于</span><br><span class="line"><span class="keyword">je </span>相等</span><br><span class="line"><span class="keyword">jna </span>不大于</span><br><span class="line"><span class="keyword">jnae </span>不大于或者等于</span><br><span class="line"><span class="keyword">jnb </span>不小于</span><br><span class="line"><span class="keyword">jnbe </span>不小于或等于</span><br><span class="line"><span class="keyword">jne </span>不等于</span><br><span class="line"><span class="keyword">jg </span>大于(有符号)</span><br><span class="line"><span class="keyword">jge </span>大于等于(有符号)</span><br><span class="line"><span class="keyword">jl </span>小于(有符号)</span><br><span class="line"><span class="keyword">jle </span>小于等于(有符号)</span><br><span class="line"><span class="keyword">jng </span>不大于(有符号)</span><br><span class="line"><span class="keyword">jnge </span>不大于等于(有符号)</span><br><span class="line"><span class="keyword">jnl </span>不小于</span><br><span class="line"><span class="keyword">jnle </span>不小于等于</span><br><span class="line"><span class="keyword">jns </span>无符号</span><br><span class="line"><span class="keyword">jnz </span>非零</span><br><span class="line"><span class="keyword">js </span>如果带符号</span><br><span class="line"><span class="keyword">jz </span>如果为零</span><br></pre></td></tr></table></figure>

<p>好了，这就是一些条件跳转指令，将它们配合着前面的cmp指令一起使用，就能够达到if语句的效果。</p>
<p>What？这该不会都得记住吧？其实不用，这里面是有套路的：</p>
<p>首先，跳转指令的前面都是字母j<br>关键是j后面的的字母<br>比如j后面是ne，对应的是jne跳转指令，n和e分别对应not和equal，也就是“不相等”，也就是说在比较指令的结果为“不想等”的时候，就会跳转。</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">a:</span> above</span><br><span class="line"><span class="symbol">e:</span> equal</span><br><span class="line"><span class="symbol">b:</span> below</span><br><span class="line"><span class="symbol">n:</span> not</span><br><span class="line"><span class="symbol">g:</span> greater</span><br><span class="line"><span class="symbol">l:</span> lower</span><br><span class="line"><span class="symbol">s:</span> signed</span><br><span class="line"><span class="symbol">z:</span> zero</span><br></pre></td></tr></table></figure>

<p>好了，这里列出来了j后面的字母所对应的含义。根据这些字母的组合，和上述大概的规则，你就能清楚怎么写出这些跳转指令了。当然，这里有“有符号”和“无符号”之分，后面有机会再扯，读者也可以自行了解。</p>
<p>那么，接下来，就可以写出这样的程序所对应的汇编代码了：</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ma<span class="meta">in(</span>) &#123;</span><br><span class="line">    int <span class="meta">x</span> = 10;</span><br><span class="line">    <span class="meta">if</span> ( <span class="meta">x</span> &gt; 100 ) &#123;</span><br><span class="line">        <span class="meta">x</span> = <span class="meta">x</span> - 20;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">if</span>( <span class="meta">x</span> &lt;= 10 ) &#123;</span><br><span class="line">        <span class="meta">x</span> = <span class="meta">x</span> + 10;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">x</span> = <span class="meta">x</span> + 1;</span><br><span class="line">    <span class="meta">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序没什么卵用，存粹是为了演示。按照前面的套路，其实写出汇编代码也就不难了：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">100</span></span><br><span class="line">    <span class="keyword">jle</span> lower_or_equal_100</span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">20</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">lower_or_equal_100:</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">10</span></span><br><span class="line">    <span class="keyword">jg</span> greater_10</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">greater_10:</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>至于更多可能的写法，那就可以慢慢玩了。</p>
<h3 id="if都有了，那else-if和else怎么办呢？"><a href="#if都有了，那else-if和else怎么办呢？" class="headerlink" title="if都有了，那else if和else怎么办呢？"></a>if都有了，那else if和else怎么办呢？</h3><p>这里就不再赘述了，理一下思路：</p>
<p>首先根据你的需要，画出整个程序的流程图<br>按照流程图中的跳转关系，通过汇编表达出来<br>也就是说，在汇编里面，实际上没有所谓的if或else的说法，只是前面为方便说明，使用了C语言作类比，实际上汇编还可以写得比C语言的判断更加灵活。</p>
<p>事实上，C语言里面的几种常见的if组织结构，都有对应的汇编语言里的套路。说白了，都是套路。</p>
<p>那你怎么才能知道这些套路呢？很简单，用C语言写一个简单的程序，编译后按之前文章所说的内容，使用gdb去反汇编然后就能知道这里面的具体做法了。</p>
<p>下面来尝试下一下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line">    register <span class="built_in">int</span> grade = <span class="number">80</span>;</span><br><span class="line">    register <span class="built_in">int</span> level;</span><br><span class="line">    <span class="keyword">if</span> ( grade &gt;= <span class="number">85</span> )&#123;</span><br><span class="line">        level = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( grade &gt;= <span class="number">70</span> ) &#123;</span><br><span class="line">        level = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( grade &gt;= <span class="number">60</span> ) &#123;</span><br><span class="line">        level = <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        level = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（程序中有一个register关键字，是用来限定这个变量在编译后只能用寄存器来进行表示，方便我们进行分析。读者可以根据需要，去掉register关键字后比较一下反汇编代码有何不同。）</p>
<p>这是一个很经典的多分支程序结构。先编译运行，程序返回值为2。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>gcc -m32 grade.c -o grade </span><br><span class="line"><span class="variable">$ </span>./grade ; echo <span class="variable">$?</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>好了，接下来，用gdb进行反汇编：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> gdb ./grade</span><br><span class="line">(gdb) <span class="keyword">set</span> disassembly-flavor <span class="comment">intel</span></span><br><span class="line">(gdb) disas <span class="comment">main</span></span><br></pre></td></tr></table></figure>

<p>得到的反汇编代码如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function main:</span><br><span class="line">   <span class="number">0x080483ed</span> &lt; +<span class="number">0</span>&gt;:    <span class="keyword">push</span>   <span class="built_in">ebp</span></span><br><span class="line">   <span class="number">0x080483ee</span> &lt; +<span class="number">1</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line">   <span class="number">0x080483f0</span> &lt; +<span class="number">3</span>&gt;:    <span class="keyword">push</span>   <span class="built_in">ebx</span></span><br><span class="line">   <span class="number">0x080483f1</span> &lt; +<span class="number">4</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x50</span></span><br><span class="line">   <span class="number">0x080483f6</span> &lt; +<span class="number">9</span>&gt;:    <span class="keyword">cmp</span>    <span class="built_in">ebx</span>,<span class="number">0x54</span></span><br><span class="line">   <span class="number">0x080483f9</span> &lt;+<span class="number">12</span>&gt;:    <span class="keyword">jle</span>    <span class="number">0x8048402</span> &lt;main+<span class="number">21</span>&gt;</span><br><span class="line">   <span class="number">0x080483fb</span> &lt;+<span class="number">14</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x08048400</span> &lt;+<span class="number">19</span>&gt;:    <span class="keyword">jmp</span>    <span class="number">0x804841f</span> &lt;main+<span class="number">50</span>&gt;</span><br><span class="line">   <span class="number">0x08048402</span> &lt;+<span class="number">21</span>&gt;:    <span class="keyword">cmp</span>    <span class="built_in">ebx</span>,<span class="number">0x45</span></span><br><span class="line">   <span class="number">0x08048405</span> &lt;+<span class="number">24</span>&gt;:    <span class="keyword">jle</span>    <span class="number">0x804840e</span> &lt;main+<span class="number">33</span>&gt;</span><br><span class="line">   <span class="number">0x08048407</span> &lt;+<span class="number">26</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x2</span></span><br><span class="line">   <span class="number">0x0804840c</span> &lt;+<span class="number">31</span>&gt;:    <span class="keyword">jmp</span>    <span class="number">0x804841f</span> &lt;main+<span class="number">50</span>&gt;</span><br><span class="line">   <span class="number">0x0804840e</span> &lt;+<span class="number">33</span>&gt;:    <span class="keyword">cmp</span>    <span class="built_in">ebx</span>,<span class="number">0x3b</span></span><br><span class="line">   <span class="number">0x08048411</span> &lt;+<span class="number">36</span>&gt;:    <span class="keyword">jle</span>    <span class="number">0x804841a</span> &lt;main+<span class="number">45</span>&gt;</span><br><span class="line">   <span class="number">0x08048413</span> &lt;+<span class="number">38</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x3</span></span><br><span class="line">   <span class="number">0x08048418</span> &lt;+<span class="number">43</span>&gt;:    <span class="keyword">jmp</span>    <span class="number">0x804841f</span> &lt;main+<span class="number">50</span>&gt;</span><br><span class="line">   <span class="number">0x0804841a</span> &lt;+<span class="number">45</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x4</span></span><br><span class="line">   <span class="number">0x0804841f</span> &lt;+<span class="number">50</span>&gt;:    <span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="built_in">ebx</span></span><br><span class="line">   <span class="number">0x08048421</span> &lt;+<span class="number">52</span>&gt;:    <span class="keyword">pop</span>    <span class="built_in">ebx</span></span><br><span class="line">   <span class="number">0x08048422</span> &lt;+<span class="number">53</span>&gt;:    <span class="keyword">pop</span>    <span class="built_in">ebp</span></span><br><span class="line">   <span class="number">0x08048423</span> &lt;+<span class="number">54</span>&gt;:    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>篇幅有限，这里就留给读者练习分析了。其中有几个需要注意的地方：</p>
<p>部分无关指令可以直接忽略掉，如：push、pop等<br>跳转指令后的&lt;main+21&gt;，就对应的是反汇编指令前是&lt;+21&gt;的指令<br>根据上述反汇编代码，分析出程序的流程图，与C语言程序的代码进行比较。仔细分析，你应该就发现jmp指令有什么用了吧。</p>
<h3 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h3><p>到这里，有一个问题出现了，在汇编语言里面实现“先比较，后跳转”的功能时，后面的跳转指令是怎么利用前面的比较结果的呢？</p>
<p>这就涉及到另一个寄存器了。在此之前，先想一下，如果自己在脑子里思考同样的逻辑，是怎么样的？</p>
<p>先比较两个数<br>记住比较结果<br>根据比较结果作出决定<br>好了，这里又来了一个“记住”的动作了。CPU里面也有一个专用的寄存器，用来专门“记住”这个cmp指令的比较结果的，而且，不仅是cmp指令，它还会自动记住其它一些指令的结果。这个寄存器就是：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">eflags</span></span><br></pre></td></tr></table></figure>

<p>名为“标志寄存器”，它的作用就是记住一些特殊的CPU状态，比如前一次运算的结果是正还是负、计算过程有没有发生进位、计算结果是不是零等信息，而后续的跳转指令，就是根据eflags寄存器中的状态，来决定是否要进行跳转的。</p>
<p>cmp指令实际上是在对两个操作数进行减法，减法后的一些状态最终就会反映到eflags寄存器中。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这回着重说到了汇编语言中与流程控制相关的内容。其中主要包括：</p>
<ul>
<li>eip寄存器指示着CPU接下来要执行哪里的代码</li>
<li>一系列跳转指令，跳转指令根本上就是修改了eip</li>
<li>比较指令，比较指令实际上是在做减法，然后把结果的一些状态放到eflags寄存器中</li>
<li>eflags寄存器的作用</li>
<li>条件跳转指令也就是根据eflags中的信息来决定是否跳转</li>
</ul>
<p>当然，这里讲述的仅仅是一部分相关的指令，带领读者对这部分内容有一个直观的认识。实际上汇编语言中与流程相关的指令不止这些，读者可自行查阅相关的资料：</p>
<ul>
<li>x86标志寄存器</li>
<li>x86影响标志寄存器的指令</li>
<li>x86跳转指令</li>
</ul>
<p>本文内容相比之前要更多一些，若想要完全理解，也需要仔细阅读，多思考、多尝试，多验证，也可以参考更多其它方面的资料。</p>
<p>文中若有疏漏之处，欢迎指正。</p>
<p>编辑于 2019-05-08</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%85%AD%EF%BC%9A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/">
    
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ljxhb@126.com">
      <meta itemprop="description" content="记录生活的点点滴滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nonlee - 工作经验分享">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%85%AD%EF%BC%9A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">汇编语言入门六：流程控制（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-31 23:24:53" itemprop="dateCreated datePublished" datetime="2019-10-31T23:24:53+08:00">2019-10-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">汇编语言</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%85%AD%EF%BC%9A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="汇编语言入门六：流程控制（二）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%85%AD%EF%BC%9A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%85%AD%EF%BC%9A%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zhuanlan.zhihu.com/p/23902265" target="_blank" rel="noopener" title="原文链接">原文链接</a></p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>前面说到在汇编语言中实现类似C语言if-else if-else这样的结构，</p>
<p>实际上，在汇编里面，我们并不关心if了，取而代之的是两种基本的指令：</p>
<ul>
<li>比较</li>
<li>跳转</li>
</ul>
<p>这两种指令即可组成最基本的分支程序结构，虽然跳转指令非常多，但是我们已经有套路了，怎么跳转都不怕了。当然，在编程环境中仅有分支还不够的，我们知道C语言中除了分支结构之外，还有循环这个最基本也是最常用的形式。正好，这也是本节话题的主角。</p>
<p>文中涉及一些汇编代码，建议读者自行编程，通过动手实践来加深对程序的理解。</p>
<h3 id="拆散循环结构"><a href="#拆散循环结构" class="headerlink" title="拆散循环结构"></a>拆散循环结构</h3><p>上回说到C语言中if这样的结构，在汇编里对应的是怎么回事，实质上，这就是分支结构的程序在汇编里的表现形式。</p>
<p>实际上，循环结构相比分支结构，本质上，没有多少变化，仅仅是比较合跳转指令的组合的方式与顺序有所不同，所以形成了循环。</p>
<p>当然，这个说法可能稍微拗口了一点。说得简单一点，循环的一个关键特点就是：</p>
<ul>
<li>程序在往回跳转</li>
</ul>
<p>细细想，好像有道理哦，如果程序每到一个位置就往前跳转，那就是死循环，如果是在这个位置根据条件决定是否要向前跳转，那就是有条件的循环了。</p>
<p>口说无凭，还是先来分析一下一个C语言的while循环：</p>
<p>(Talk is chip, show your code!)</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( i &lt;= <span class="number">10</span> ) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想必这段程序多数人都非常熟悉了，当年自己第一次学习循环的时候就碰到这个题目，脑子短路了，心里总想着这不就是一个等差数列公式么，题目却强行出现在循环一章的后面，最后结果让人大跌眼睛，这是要我老老实实像SHAB一样去加啊。</p>
<p>跑题了，先大致总结一下这个程序的关键部分到底在干什么：</p>
<ul>
<li>1 比较i和10的大小</li>
<li>2 如果i &lt;= 10则执行代码块，并回到(1)</li>
<li>3 如果不满足 i &lt;= 10，则跳过代码块</li>
</ul>
<p>好了，按照这个逻辑，在C语言中不使用循环怎么实现？其实也非常简单：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sum = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"><span class="keyword">if</span>( i &lt;= <span class="number">10</span> ) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">    goto _start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这还不够，我们还得做一次变形，为什么呢？回想一下前面说的分之程序在汇编里的情况：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">( a &gt; 10 )</span> &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述C代码，暂且成为“正宗C代码”，等价的汇编大致结构如下：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmp eax, <span class="number">10</span></span><br><span class="line">jle <span class="keyword">out</span><span class="number">_</span><span class="keyword">of</span><span class="number">_</span>block</span><br><span class="line"></span><br><span class="line">; some code</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span><span class="number">_</span><span class="keyword">of</span><span class="number">_</span>block:</span><br></pre></td></tr></table></figure>

<p>再等价变换回C语言，这里把这种风格叫做“山寨C代码”，实际上就是这样的：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( a &lt;= <span class="number">10</span> ) goto <span class="keyword">out</span><span class="number">_</span><span class="keyword">of</span><span class="number">_</span>block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span><span class="number">_</span><span class="keyword">of</span><span class="number">_</span>block:</span><br></pre></td></tr></table></figure>

<p>经过比较，我们可以发现“山寨C代码”和“正宗C代码”之间的一些区别：</p>
<ul>
<li>山寨版中，if块里只需要放一条跳转语句即可</li>
<li>山寨版中，if里的条件是反过来的</li>
<li>山寨版中，跳转语句的功能是跳过“正宗C代码”的if块</li>
</ul>
<p>相当于是：不满足条件就跳过if中的语句块。</p>
<p>那循环呢？咱们把循环的C等价代码做一次变换，也就是把只含有goto和if的“正宗C代码”变换为“山寨C代码”的形式：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"><span class="keyword">if</span>( i &gt; <span class="number">10</span> ) &#123;</span><br><span class="line">    <span class="keyword">goto</span> _end_of_block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> = <span class="built_in">sum</span> + i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> _start;</span><br><span class="line"></span><br><span class="line">_end_of_block:</span><br></pre></td></tr></table></figure>

<p>大致看一下流程，再对比源代码：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( i &lt;= <span class="number">10</span> ) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">自己在脑子里面模拟一</span><br></pre></td></tr></table></figure>
<p>遍，是不是就能发现什么了？这俩货分明就是一个东西，执行的顺序和过程完全就是一样的。</p>
<p>到这里，我们的循环结构，全都被拆散成了最基本的结构，这种结构有一个关键的特点：</p>
<p>所有if块中都仅有一条goto语句，别的啥都没了<br>到这里，本段就到位了。</p>
<h3 id="用汇编写出循环"><a href="#用汇编写出循环" class="headerlink" title="用汇编写出循环"></a>用汇编写出循环</h3><p>前面已经介绍了“如何把一个循环拆解成只有if和goto的结构”，有了这个结构之后，其实要写出汇编就非常容易了。</p>
<p>继续看山寨版的循环：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"><span class="keyword">if</span>( i &gt; <span class="number">10</span> ) &#123;</span><br><span class="line">    <span class="keyword">goto</span> _end_of_block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> = <span class="built_in">sum</span> + i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> _start;</span><br><span class="line"></span><br><span class="line">_end_of_block:</span><br></pre></td></tr></table></figure>

<p>其实，稍微仔细一点就能发现，把这玩意儿写成汇编，就是逐行翻译就完事儿了。动手：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="number">1</span></span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">ebx</span>, <span class="number">10</span></span><br><span class="line">    <span class="keyword">jg</span> _end_of_block</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">jmp</span> _start</span><br><span class="line">    </span><br><span class="line"><span class="symbol">_end_of_block:</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>这里面其实有一个套路：</p>
<ul>
<li>单条goto语句可以直接用jmp语句替代</li>
<li>if和goto组合的语句块可以用cmp和j*指令的组合替代<br>最后，其它语句该干啥干啥。</li>
</ul>
<p>这？竟然？就？用汇编？写出？循环？来了？</p>
<p>嗯，是的。不需要任何一个新的指令，全都是前面提及过的基本指令，只是套路不一样了而已。</p>
<p>其实这就是一个套路，稍微总结一下就能发现，一个将while循环变换为汇编的过程如下：</p>
<p>将while循环拆解成只有if和goto的形式<br>将if形式的语句拆解成if块中仅有一行goto语句的形式<br>从前往后逐行翻译成汇编语言<br>其它循环呢？<br>那while循环能够搞定了，其它类型的呢？do-while循环、for循环呢？</p>
<p>其实，在C语言中，这三种循环之间都是可以相互变换的，也就是说for循环可以变形成为while循环，while循环也可以变成for循环。举个例子：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i ++) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( i &lt;= <span class="number">10</span> ) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个片段的代码，其实就是等价的，仅仅是形式不同。只是有的循环思路用for循环写出来好看一些，有的思路用while循环写出来好看一些，别的没什么本质区别，经过编译器一倒腾之后，就更没有任何区别了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在汇编中，分支和循环结构，都是通过两类基本的指令实现的：</p>
<ul>
<li>比较</li>
<li>跳转</li>
</ul>
<p>只是，分支结构的程序中，所有的跳转目标都是往后，程序一去不复返。而循环结构中，程序会根据条件往前跳转，跳回去执行已经执行过的代码，在绕圈圈，就成循环了。到汇编层面，本质上，没啥区别。</p>
<p>好了，汇编语言中的流程控制，基本就算完事儿了，实际上，在汇编语言中，抓住根本的东西就行了，剩下的就是靠脑子想象了。</p>
<p>文中若有疏漏之处，欢迎指正。</p>
<p>编辑于 2019-05-08</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%83%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/">
    
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ljxhb@126.com">
      <meta itemprop="description" content="记录生活的点点滴滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nonlee - 工作经验分享">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%83%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">汇编语言入门七：函数调用（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-31 23:25:31" itemprop="dateCreated datePublished" datetime="2019-10-31T23:25:31+08:00">2019-10-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">汇编语言</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%83%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="汇编语言入门七：函数调用（一）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%83%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B8%83%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zhuanlan.zhihu.com/p/24129384" target="_blank" rel="noopener" title="原文链接">原文链接</a></p>
<p>最近忙了一阵，好几天没更了，不好意思，我来晚了。</p>
<p>转入正题，当在汇编中进行函数调用，是一种什么样的体验？</p>
<h3 id="想象"><a href="#想象" class="headerlink" title="想象"></a>想象</h3><p>想象你在计算一个非常复杂的数学题，在算到一半的时候，你需要一个数据，而这个数据需要套用一个比较复杂的公式才能算出来，怎么办？</p>
<p>你不得不把手中的事情停下来，先去套公式、代入数值然后…最后，算出结果来了。</p>
<p>这时候你继续开始攻克这个困难题目的剩下部分。</p>
<h3 id="用脑子想"><a href="#用脑子想" class="headerlink" title="用脑子想"></a>用脑子想</h3><p>刚刚说的这个过程，可能有点小问题，尤其是对脑子不太好使的人来说。想象你做题目做到一半的时候，记忆力已经有点不好使了，中间突然停下来去算一个复杂的公式，然后回来，诶？我刚刚算到哪了？我刚刚想到哪了？我刚刚算了些什么结果？</p>
<p>在你工作切换的时候，很容易回头来就忘记了刚刚做的部分事情。这时候，为了保证你套完复杂的公式，把结果拿回来继续算题目的时候不会出差错，你需要把刚才计算题目过程中的关键信息写在纸上。</p>
<h3 id="用CPU想"><a href="#用CPU想" class="headerlink" title="用CPU想"></a>用CPU想</h3><p>刚刚去套用一个复杂的公式计算某个数据的情景，就类似在计算机里进行函数调用的情景。</p>
<p>程序需要一个结果，这个结果需要通过一个比较复杂的过程进行计算。这时候，编程人员会考虑将这个独立的复杂过程提取为单独的函数。</p>
<p>而在发生函数调用的时候，CPU就像是先暂停当前所做的事情，转去做那个复杂的计算，算完了之后又跳回来继续整个计算。就像你做题的过程中去套了一个公式计算数据一样。</p>
<p>但是在去套用公式之前，你需要做一些准备。首先，默默记下现在这个题目算到哪一步了，一会套完公式回来接着做；默默记下现在计算出来的一些结果，一会可能还会用到；套用公式需要些什么数据，先记下来，代公式的时候直接代入计算，算出来的结果也需要记在脑子里，回头需要使用。</p>
<p>在CPU里面，也需要这几个过程。</p>
<p>第一个，记下自己现在做事情做到哪里了，一会儿套完公式回来接着做，这也就是CPU在进行函数调用时的现场保存操作，CPU也需要记下自己当前执行到哪里了。</p>
<p>默默记下一些在套用公式的时候需要用到的数据，然后去套公式了。这也就是程序中在调用函数的时候进行参数传递的过程。</p>
<p>然后开始执行函数，等函数执行完了，就需要把结果记下来，回去继续刚才要用到数据的那个地方继续算。这也就是函数调用后返回的动作，这个记下的结果就是返回值。</p>
<h3 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h3><p>说了那么多故事，那么函数调用要干些啥应该就说清楚了。总结一下大概就这么几个事：</p>
<p>保存现场（一会好回来接着做）<br>传递参数（可选，套公式的时候需要些什么数据）<br>返回（把计算结果带回来，接着刚才的事）<br>到这里，我们先来一个事例代码，就着代码去发现函数调用中的套路：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">eax_plus_1s:</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">ebx_plus_1s:</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">call</span> eax_plus_1s</span><br><span class="line">    <span class="keyword">call</span> eax_plus_1s</span><br><span class="line">    <span class="keyword">call</span> ebx_plus_1s</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>首先，运行程序，得到结果：3。</p>
<p>上面的代码其实也比较简单，先从主干main这个地方梳理：</p>
<ol>
<li>让eax和ebx的值都为0</li>
<li>调用eax_plus_1s，再调用eax_plus_1s</li>
<li>调用ebx_plus_1s</li>
<li>执行eax = eax + ebx</li>
</ol>
<p>上述的两个函数也非常简单，分别就是给eax和ebx加了1。所以，这个程序其实也就是换了个花样给寄存器增加1而已，纯粹演示。</p>
<p>这里出现了一个陌生指令call，这个指令是函数调用专用的指令，从程序的行为上看应该是让程序的执行流程发生跳转。前面说到了跳转指令jmp，这里是call，这两个指令都能让CPU的eip寄存器发生突然变化，然后程序就一下子跳到别的地方去了。但是这两个有区别：</p>
<p>很简单，jmp跳过去了就不知道怎么回来了，而通过call这种方式跳过去后，是可以通过ret指令直接回来的</p>
<p>那这是怎么做到的呢？</p>
<p>其实，在call指令执行的时候，CPU进行跳转之前还要做一个事情，就是把eip保存起来，然后往目标处跳。当遇到ret指令的时候，就把上一次call保存起来的eip恢复回来，我们知道eip直接决定了CPU会执行哪里的代码，当eip恢复的时候，就意味着程序又会到之前的位置了。</p>
<p>一个程序免不了有很多次call，那这些eip的值都是保存到哪里的呢？</p>
<p>有一个地方叫做“栈(stack)”，是程序启动之前，由操作系统指定的一片内存区域，每一次函数调用后的返回地址都存放在栈里面</p>
<p>好了，我们到这里，就明白了函数调用大概是怎么回事了。总结起来就是：</p>
<p>本质上也是跳转，但是跳到目标位置之前，需要保存“现在在哪里”的这个信息，也就是eip<br>整个过程由一条指令call完成<br>后面可以用ret指令跳转回来<br>call指令保存eip的地方叫做栈，在内存里，ret指令执行的时候是直接取出栈中保存的eip值，并恢复回去达到返回的效果<br>何为栈？<br>前面说到call指令会先保存eip的值到栈里面，然后就跳转到目标函数中去了。</p>
<p>这都好说，但是，如果是我在函数里面调用了一个函数，在这个函数里面又调用了一个函数，这个eip是怎么保存来保证每一次都能正确的跳回来呢？</p>
<p>好的，这个问题才是关键，这也说到了栈这样一个东西，我们先来设想一些场景，结合实际代码理解一下CPU所对应的栈。</p>
<p>首先，这个栈和数据结构中的栈是不一样的。数据结构中的栈是通过编程语言来形成程序执行逻辑上的栈。而这里的栈，是CPU内硬件实现的栈。当然了，两者在逻辑上都差不多的。</p>
<p>在这里，先回想一下数据结构中基于数组实现的栈。里面最关键的就是需要一个栈顶指针（或者是一个索引、下标），每次放东西入栈，就将指针后移，每一次从栈中取出东西来，就将指针前移。</p>
<p>到这里，我们先从逻辑上分析下CPU在发生函数调用的过程中是如何使用栈的。</p>
<p>假设现在程序处在一个叫做level1的位置，并调用了函数A，在调用的跳转发生之前，会将当前的eip保存起来，这时候，栈里面就是这样的：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">----------    </span>&lt;=   top</span><br><span class="line"><span class="code">  level1</span></span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p>现在，程序处在level2的位置，又调用了函数B，同样，也会保存这次的eip进去：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">----------    </span>&lt;=   top</span><br><span class="line"><span class="code">  level2</span></span><br><span class="line">----------</span><br><span class="line"><span class="code">  level1</span></span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p>再来，程序这次处在level3，调用了C函数，这时候，整个栈就是这样的：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">----------    </span>&lt;=   top</span><br><span class="line"><span class="code">  level3</span></span><br><span class="line">----------</span><br><span class="line"><span class="code">  level2</span></span><br><span class="line">----------</span><br><span class="line"><span class="code">  level1</span></span><br><span class="line">----------</span><br></pre></td></tr></table></figure>

<p>好了，这下程序执行到了ret，会发生什么事，是不是就回到level3了？在level3中再次执行ret，是不是就回到level2了？以此类推，最终，程序就能做到一层层的函数调用和返回了。</p>
<h3 id="实际的CPU中"><a href="#实际的CPU中" class="headerlink" title="实际的CPU中"></a>实际的CPU中</h3><p>在实际的CPU中，上述的栈顶top也是由一个寄存器来记录的，这个寄存器叫做</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">esp</span><span class="params">(stack pointer)</span></span></span><br></pre></td></tr></table></figure>
<p>每次执行call指令的时候。</p>
<p>这里还有一个小细节，在x86的环境下，栈是朝着低地址的方向伸长的。什么意思呢？每一次有东西入栈，那么栈顶指针就会递减一个单位，每一次出栈，栈顶指针就会相应地增加一个单位（和数据结构中一般的做法是相反的）。至于为什么会这样，我也不知道。</p>
<p>eip在入栈的时候，大致就相当于执行了这样一些指令：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub</span> <span class="built_in">esp</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span>[<span class="built_in">esp</span>], <span class="built_in">eip</span></span><br></pre></td></tr></table></figure>

<p>翻译为C语言就是（假如esp是一个void*类型的指针）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp = (<span class="name">void*</span>)( ((<span class="name">unsigned</span> int)esp) - <span class="number">4</span> )</span><br><span class="line">*( (<span class="name">unsigned</span> int*) esp ) = (<span class="name">unsigned</span> int) eip</span><br></pre></td></tr></table></figure>

<p>也就是esp先移动，然后再把eip的值写入到esp指向的内存中。那么，ret执行的时候该干什么，也就非常的清楚了吧。无非就是上述过程的逆过程。</p>
<p>同时，eip寄存器的长度为32位，即4字节，所以每一次入栈出栈的单位大小都是4字节。</p>
<h3 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h3><p>没有代码，说个锤子。先来一个简单的程序：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">eax_plus_1s:</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">call</span> eax_plus_1s</span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>这个程序中只有一个函数调用，但不影响我们分析。先编译，得到一个可执行文件，这里先起名为plsone。</p>
<p>然后载入gdb进行调试，进行反汇编：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./plsone</span><br><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   <span class="number">0x080483f4</span> &lt;+<span class="number">0</span>&gt;: <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">   <span class="number">0x080483f9</span> &lt;+<span class="number">5</span>&gt;: <span class="keyword">call</span>   <span class="number">0x80483f0</span> &lt;eax_plus_1s&gt;</span><br><span class="line">   <span class="number">0x080483fe</span> &lt;+<span class="number">10</span>&gt;:    <span class="keyword">ret</span>    </span><br><span class="line">   <span class="number">0x080483ff</span> &lt;+<span class="number">11</span>&gt;:    <span class="keyword">nop</span></span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>好了，找到反汇编中&lt;+5&gt;所在那一行，对应着的指令是call 0x80483f0，这个指令的地址为：0x080483f9（不同的环境有所不同，根据实际情况来）。按照套路，在这个call指令处打下一个断点，然后运行程序。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *<span class="number">0x080483f9</span> </span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x80483f9</span></span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/vagrant/code/asm/<span class="number">07</span>/plsone </span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="number">0x080483f9</span> <span class="keyword">in</span> main ()</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>好了，程序执行到断点处，停下来了。再来看反汇编，这次有一个小箭头指向当前的断点了：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler <span class="built_in">code</span> for function ma<span class="symbol">in:</span></span><br><span class="line">   <span class="number">0</span>x080483f4 &lt;+<span class="number">0</span>&gt;<span class="symbol">:</span> mov    $<span class="number">0</span>x0,%eax</span><br><span class="line">=&gt; <span class="number">0</span>x080483f9 &lt;+<span class="number">5</span>&gt;<span class="symbol">:</span> <span class="built_in">call</span>   <span class="number">0</span>x80483f0 &lt;eax_plus_1s&gt;</span><br><span class="line">   <span class="number">0</span>x080483fe &lt;+<span class="number">10</span>&gt;<span class="symbol">:</span>    ret    </span><br><span class="line">   <span class="number">0</span>x080483ff &lt;+<span class="number">11</span>&gt;<span class="symbol">:</span>    nop</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>接下来，做这样一个事情，看看现在eip的值是多少：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info register <span class="built_in">eip</span></span><br><span class="line"><span class="built_in">eip</span>            <span class="number">0x80483f9</span>    <span class="number">0x80483f9</span> &lt;main+<span class="number">5</span>&gt;</span><br></pre></td></tr></table></figure>

<p>正好指向这个函数调用指令。这里的call指令还没执行，现在的CPU处在上一条指令刚执行完毕的状态。前面说过，CPU中的eip总是指向下一条会执行的指令。在这里，珍惜机会，我们把想看的东西全都看个遍吧：</p>
<p>esp的值，这个很关键</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info register <span class="built_in">esp</span></span><br><span class="line"><span class="built_in">esp</span>            <span class="number">0xffffd6ec</span>   <span class="number">0xffffd6ec</span></span><br></pre></td></tr></table></figure>

<p>esp所指向的栈顶的东西</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x *(unsigned <span class="built_in">int</span>*)$esp</span><br><span class="line">$<span class="number">1</span> = <span class="number">0xf7e40ad3</span></span><br></pre></td></tr></table></figure>

<p>该看的都看过了，让程序走吧，让它先执行完了call指令，我们再回头看看什么情况：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">gdb</span>) stepi</span><br><span class="line"><span class="number">0</span>x080483f0 in eax_plus_1s ()</span><br></pre></td></tr></table></figure>

<p>根据提示，程序现在已经执行到函数里面去了。可以直接反汇编看看：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler <span class="built_in">code</span> for function eax_plus_1<span class="symbol">s:</span></span><br><span class="line">=&gt; <span class="number">0</span>x080483f0 &lt;+<span class="number">0</span>&gt;<span class="symbol">:</span> add    $<span class="number">0</span>x1,%eax</span><br><span class="line">   <span class="number">0</span>x080483f3 &lt;+<span class="number">3</span>&gt;<span class="symbol">:</span> ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>现在正等着执行那条加法指令呢。别急，现在函数调用已经发生了，再来看看上面我们看过的一些东西：</p>
<p>esp的值，这个很关键</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info register <span class="built_in">esp</span></span><br><span class="line"><span class="built_in">esp</span>            <span class="number">0xffffd6e8</span>   <span class="number">0xffffd6e8</span></span><br></pre></td></tr></table></figure>

<p>看到了，上次查看esp的时候是0xffffd6ec，进入函数后的esp值是0xffffd6e8。少了个4。</p>
<p>实际上这就是eip被保存到栈里去了，CPU的栈的伸长方向是朝着低地址一侧的，所以每次入栈，esp都会减少一个单位，也就是4。</p>
<p>esp所指向的栈顶的东西</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p/x *(unsigned <span class="built_in">int</span>*)$esp</span><br><span class="line">$<span class="number">2</span> = <span class="number">0x80483fe</span></span><br></pre></td></tr></table></figure>

<p>这次，我们看看栈顶到底是个什么东西，打印出来0x80483fe这么一个玩意儿，这是蛤玩意儿？别急，回头看看main函数的反汇编：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   <span class="number">0x080483f4</span> &lt;+<span class="number">0</span>&gt;: <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line">   <span class="number">0x080483f9</span> &lt;+<span class="number">5</span>&gt;: <span class="keyword">call</span>   <span class="number">0x80483f0</span> &lt;eax_plus_1s&gt;</span><br><span class="line">   <span class="number">0x080483fe</span> &lt;+<span class="number">10</span>&gt;:    <span class="keyword">ret</span>    </span><br><span class="line">   <span class="number">0x080483ff</span> &lt;+<span class="number">11</span>&gt;:    <span class="keyword">nop</span></span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>在里面找找0x80483fe呢？刚好在&lt;+10&gt;所在的那一行。这不就是函数调用指令处的后一条指令吗？</p>
<p>对的，也就是说，一会函数返回的时候，就会到&lt;+10&gt;这个地方来。也就是在执行了eax_plus_1s函数里的ret之后。</p>
<p>是不是和前面描述的过程一模一样？</p>
<p>好了，到这里，探究汇编中的函数调用的过程和方法基本就有了，读者可以根据需要自行编写更加奇怪的代码，结合gdb，来探究更多你自己所好奇的东西。</p>
<p>附加一个代码，自己玩耍试试（在自己的环境中玩耍哦）：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">global main</span><br><span class="line"></span><br><span class="line"><span class="symbol">hahaha:</span></span><br><span class="line">    <span class="keyword">call</span> hehehe</span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">hehehe:</span></span><br><span class="line">    <span class="keyword">call</span> hahaha</span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">call</span> hahaha</span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这回，我们说到这样一些东西：</p>
<p>汇编中发生函数调用相关的指令call和ret<br>call指令会产生跳转动作，与jmp不同的是，call之后可以通过ret指令跳回来<br>call和ret的配合是依靠保存eip的值到栈里，返回时恢复eip实现的<br>esp记录着当前栈顶所在的位置，每次call和ret执行都会伴随着入栈和出栈，也就是esp会发生变化<br>函数调用最基本的”跳转“和”返回“就这么回事了，下回咱们继续分析”函数调用中的参数传递、返回值和状态“相关的问题。</p>
<p>文中若有疏漏或是不当之处，欢迎指正。</p>
<p>发布于 2016-12-02</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%85%AB%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/">
    
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ljxhb@126.com">
      <meta itemprop="description" content="记录生活的点点滴滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nonlee - 工作经验分享">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%85%AB%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">汇编语言入门八：函数调用（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-31 23:25:45" itemprop="dateCreated datePublished" datetime="2019-10-31T23:25:45+08:00">2019-10-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">汇编语言</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%85%AB%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="汇编语言入门八：函数调用（二）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%85%AB%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%85%AB%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zhuanlan.zhihu.com/p/24265088" target="_blank" rel="noopener" title="原文链接">原文链接</a></p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>上回说道，x86汇编中专门提供了两个指令call和ret，用于实现函数调用的效果。实际上函数调用就是程序跳转，只是在跳转之前，CPU会保存当前所在的位置（即返回地址），当函数返回时，又可以从调用的位置恢复。返回地址保存在一个叫做“堆栈”的地方，堆栈中可以保存很多个返回地址，同时借助于堆栈的进出逻辑，还能实现函数嵌套、递归等效果。</p>
<p>同时前面还简单地提到了函数调用过程中的参数和返回值的传递过程。实际上，在汇编语言中，函数调用的参数和返回值均可以通过寄存器来传送，只要函数内外相互配合，就可以精确地进行参数和返回值传递。</p>
<h3 id="没那么简单"><a href="#没那么简单" class="headerlink" title="没那么简单"></a>没那么简单</h3><p>到这里，看起来好像函数调用的基本要素都有了，但实际上还是有一些问题的。比如说递归调用这样的场景。通过对递归的研究，你也就能明白前面说到的函数调用机制存在什么样致命的问题。</p>
<p>好了，先说下，这部分内容，很关键。</p>
<p>举个例子，通过递归调用来计算斐波那契数列中的某一项，用高级语言编写已经非常容易：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> fibo(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibo(n - <span class="number">1</span>) + fibo(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来进行一波改造，改造成接近汇编的形式：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> fibo(<span class="built_in">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> x = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> y = n - <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int</span> a = fibo(x);</span><br><span class="line">    <span class="built_in">int</span> b = fibo(y);</span><br><span class="line">    <span class="built_in">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拆分成这样之后，就能够比较方便地和汇编对应起来了，再改造一下，把变量名全都换成寄存器名，就能够看得更清楚了（先约定eax寄存器作为函数的第一个参数，通过eax也用来传递返回值）：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fibo(<span class="keyword">int</span> <span class="built_in">eax</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">ebx</span>, <span class="built_in">ecx</span><span class="comment">;</span></span><br><span class="line">    if(<span class="built_in">eax</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        return <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    if(<span class="built_in">eax</span> == <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="built_in">eax</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">         return <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">edx</span> = <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">eax</span> = <span class="built_in">edx</span> - <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    <span class="built_in">eax</span> = fibo(<span class="built_in">eax</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">ebx</span> = <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">eax</span> = <span class="built_in">edx</span> - <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    <span class="built_in">eax</span> = fibo(<span class="built_in">eax</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">ecx</span> = <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">eax</span> = <span class="built_in">ebx</span> + <span class="built_in">ecx</span><span class="comment">;</span></span><br><span class="line">    return <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为eax会被用作参数和返回值，所以进入函数后就需要将eax保存到别的寄存器，一会需要的时候才能够更方便地使用。</p>
<p>看起来，这里的fibo函数已经比较完美了，这个函数在C语言下是能够正常运行的。接下来把它翻译成汇编：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">fibo:</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">je</span> _get_out</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">je</span> _get_out</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">call</span> fibo</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">edx</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">call</span> fibo</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">eax</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ecx</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">_get_out:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>然而，当你使用这个C语言代码翻译出来的汇编的时候，却发现结果怎么都不对了。</p>
<p>那么，问题出在哪里呢？</p>
<p>问题就出在从C语言翻译到汇编的过程中。</p>
<h3 id="警惕作用域"><a href="#警惕作用域" class="headerlink" title="警惕作用域"></a>警惕作用域</h3><p>在C函数中，虽然我们把各个变量名换成寄存器名，把复杂的语句拆分成简单语句，最后就能够和汇编语句等同起来，但是，在将C代码翻译到汇编的过程中，出现了不等价的变换。其中，变量的作用域便是引起不等价的原因之一。这个C代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fibo(<span class="keyword">int</span> <span class="built_in">eax</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">ebx</span>, <span class="built_in">ecx</span><span class="comment">;</span></span><br><span class="line">    if(<span class="built_in">eax</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        return <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    if(<span class="built_in">eax</span> == <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="built_in">eax</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">         return <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">edx</span> = <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">eax</span> = <span class="built_in">edx</span> - <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    <span class="built_in">eax</span> = fibo(<span class="built_in">eax</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">ebx</span> = <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">eax</span> = <span class="built_in">edx</span> - <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    <span class="built_in">eax</span> = fibo(<span class="built_in">eax</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">ecx</span> = <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">eax</span> = <span class="built_in">ebx</span> + <span class="built_in">ecx</span><span class="comment">;</span></span><br><span class="line">    return <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本身是没有任何问题的。但是，翻译后的汇编就有问题了，实际上上述汇编语言等价为这样的C代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">ebx</span>, <span class="built_in">ecx</span>, <span class="built_in">edx</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">void fibo() &#123;</span><br><span class="line"></span><br><span class="line">    if(<span class="built_in">eax</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">eax</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        return<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    if(<span class="built_in">eax</span> == <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="built_in">eax</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line">         return<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">edx</span> = <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">eax</span> = <span class="built_in">edx</span> - <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    <span class="built_in">eax</span> = fibo(<span class="built_in">eax</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">ebx</span> = <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">eax</span> = <span class="built_in">edx</span> - <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    <span class="built_in">eax</span> = fibo(<span class="built_in">eax</span>)<span class="comment">;</span></span><br><span class="line">    <span class="built_in">ecx</span> = <span class="built_in">eax</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">eax</span> = <span class="built_in">ebx</span> + <span class="built_in">ecx</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因很简单，CPU中的寄存器是全局可见的。所以使用寄存器，实际上就是在使用一个像全局变量一样的东西。</p>
<p>那么，到这里，通过这个例子，你应该能够发现问题了，现有的做法，无法实现递归或者嵌套的结构。</p>
<p>到底需要什么<br>实际上，要实现递归，那么就需要函数的状态是局部可见的，只能在当前这一层函数内访问。递归中会出现层层调用自己的情况，每一层之间的状态都应当保证局部性，不能相互影响。</p>
<p>在C语言的环境下，函数内的局部变量，抽象来看，实际上就是函数执行时的局部状态。在汇编环境下，寄存器是全局可见的，不能用于充当局部变量。</p>
<p>那怎么办呢？</p>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>前面说到，堆栈是用来保存函数调用后的返回地址。其实在这里，函数的返回地址，其实就是当前这一层函数的一个状态，这个状态对应的是这一层函数当前执行到哪儿了。</p>
<p>借鉴call指令保存返回地址的思路，如果，在每一层函数中都将当前比较关键的寄存器保存到堆栈中，然后才去调用下一层函数，并且，下层的函数返回的时候，再将寄存器从堆栈中恢复出来，这样也就能够保证下层的函数不会破坏掉上层函数的状了。</p>
<p>也就是，当下要解决这样一个问题：被调用函数在使用一些寄存器的时候，不能影响到调用者所使用的寄存器值，否则函数之间就很难配合好了，也很容易乱套。</p>
<h3 id="入栈与出栈"><a href="#入栈与出栈" class="headerlink" title="入栈与出栈"></a>入栈与出栈</h3><p>实际上，CPU的设计者们已经考虑过这个问题了，所以还专门提供了对应的指令来干这个事。入栈与出栈分别是两个指令：</p>
<ul>
<li>push eax            ; 将eax的值保存到堆栈中去</li>
<li>pop ebx         ; 将堆栈顶的值取出并存放到ebx中</li>
</ul>
<p>有了这两个玩意儿，递归调用这个问题就可以解决了。注意了，这里发生了入栈和出栈的情况，那么，进行栈操作的时候对应的栈顶指针也会发生相应的移动，这里也一样。</p>
<h3 id="搞一个不会影响全世界的函数"><a href="#搞一个不会影响全世界的函数" class="headerlink" title="搞一个不会影响全世界的函数"></a>搞一个不会影响全世界的函数</h3><p>先来试一试堆栈的使用，我就不废话了，举个例子，一个通过循环来计算1+2+3+4+5+6+7+…+n的函数（这里还是约定eax为第一个参数，同时eax也是返回值，暂不考虑参数不合法的情况），直接上代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sum_one_to_n:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_go_on:</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">je</span> _get_out:</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">jmp</span> _go_on</span><br><span class="line"></span><br><span class="line"><span class="symbol">_get_out:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>你可以发现，在这个函数中，不可避免地需要使用到eax之外的寄存器。但是有一个很致命的问题，调用方或者更上层的函数如果使用了ebx寄存器，这里又拿来用，最终，这个sum_one_to_n不小心把上层函数的状态给改了，最后结果和前面的递归例子差不多，总之不是什么好结果。</p>
<p>那么，这里就需要在使用ebx之前，先把ebx保存起来，使用完了之后，再把ebx恢复回来，就不会产生上述问题了。好了，接下来就需要调整代码了，只需要加一行push和pop就能完事儿了。像这样：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sum_one_to_n:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ebx</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_go_on:</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">je</span> _get_out:</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">jmp</span> _go_on</span><br><span class="line"></span><br><span class="line"><span class="symbol">_get_out:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>在函数的第一行和倒数第二行分别加入了push ebx和pop ebx指令。</p>
<p>通过push ebx，将当前的ebx寄存器保存起来。</p>
<p>通过pop ebx，堆栈中保存的ebx寄存器恢复回来。</p>
<p>当然了，进行push和pop的时候也得稍加小心，破坏了call指令保存到堆栈中的返回地址，也会坏事的。不过好在，函数内的入栈和出栈操作是保持一致的，不会影响到call指令保存的返回地址，也就不会影响到ret指令的正常工作。</p>
<h3 id="再来递归"><a href="#再来递归" class="headerlink" title="再来递归"></a>再来递归</h3><p>那么，我们就已经解决了函数内保存局部状态的问题了，其中的套路之一便是，让函数在使用某个寄存器之前，先把旧的值保存起来，等用完了之后再恢复回去，那么这个函数执行完毕后，所有的寄存器都是干干净净的，不会被函数玷污。</p>
<p>有了push和pop的解决方案，那么前面那个递归的问题也可以解决了。</p>
<p>先来分析下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">fibo:</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">je</span> _get_out</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">je</span> _get_out</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">call</span> fibo</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">edx</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">call</span> fibo</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">eax</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ecx</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">_get_out:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>这段代码中使用到了除eax之外的寄存器有ebx、ecx、edx三个。为了保证这三个寄存器不会在不同的递归层级串场，我们需要在函数内使用它们之前将其保存起来，等到不用了之后再还原回去（注意入栈和出栈的顺序是需要反过来的），像这样：。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">fibo:</span></span><br><span class="line"><span class="meta">global</span> main</span><br><span class="line"></span><br><span class="line"><span class="symbol">fibo:</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">je</span> _get_out</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">eax</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">je</span> _get_out</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ecx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">edx</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">call</span> fibo</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">edx</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">call</span> fibo</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="built_in">eax</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="built_in">ecx</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">edx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ecx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ebx</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">_get_out:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">7</span></span><br><span class="line">    <span class="keyword">call</span> fibo</span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

<p>编译运行一看，第7项的值为13，诶，这下结果可靠了。我们得到了一个汇编语言实现的、通过递归调用来计算斐波那契数列某一项值的函数。</p>
<h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>前面扯了这么多，我们说到了这样一些东西：</p>
<p>函数调用相关指令<br>通过寄存器传递参数和返回值<br>函数调用后的返回地址会保存到堆栈中<br>函数的局部状态也可以保存到堆栈中<br>C语言中的函数<br>在C语言中，x86的32位环境的一般情况下，函数的参数并不是通过寄存器来传递的，返回值也得视情况而定。这取决于编译器怎么做。</p>
<p>实际上，一些基本数据类型，以及指针类型的返回值，一般是通过寄存器eax来传递的，也就是和前面写的汇编一个套路。而参数就不是了，C中的参数一般是通过堆栈来传递的，而非寄存器（当然也可以用寄存器，不过需要加一些特殊的说明）。这里准备了一个例子，供大家体会一下C语言中通过堆栈传递参数的感觉：</p>
<p>(在32位环境下编译)</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sum(<span class="built_in">int</span> n, <span class="built_in">int</span> a, ...) &#123;</span><br><span class="line">    <span class="built_in">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> *p = &amp;a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        s += p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main() &#123;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"%d\n"</span>, sum(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -<span class="built_in">std</span>=c99 -m32 <span class="built_in">demo</span>.c -o <span class="built_in">demo</span></span><br><span class="line">$ ./<span class="built_in">demo</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>函数的参数是逐个放到堆栈中的，通过第一个参数的地址，可以挨着往后找到后面所有的参数。你还可以尝试把参数附近的内存都瞧一遍，还能找到混杂在堆栈中的返回地址。</p>
<p>若读者想要对C的函数机制一探究竟，可以尝试编写一些简单的程序，进行反汇编，研究整个程序在汇编这个层面，到底在做些什么。</p>
<p>好了，汇编语言的函数相关部分就可以告一段落了。这部分涉及到一个非常重要的东西：堆栈。这个需要读者下来多了解一些相关的资料，尝试反汇编一些有函数调用的C程序，结合相关的资料不断动手搞事情，去实实在在地体会一下堆栈。</p>
<p>文中若有疏漏或不当之处，欢迎指正。</p>
<p>发布于 2016-12-08</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B9%9D%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E5%90%8E%E7%BB%AD%EF%BC%88%E9%97%B2%E6%89%AF%EF%BC%89/">
    
    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ljxhb@126.com">
      <meta itemprop="description" content="记录生活的点点滴滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="nonlee - 工作经验分享">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B9%9D%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E5%90%8E%E7%BB%AD%EF%BC%88%E9%97%B2%E6%89%AF%EF%BC%89/" class="post-title-link" itemprop="url">汇编语言入门九：总结与后续（闲扯）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-31 23:26:04" itemprop="dateCreated datePublished" datetime="2019-10-31T23:26:04+08:00">2019-10-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">汇编语言</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B9%9D%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E5%90%8E%E7%BB%AD%EF%BC%88%E9%97%B2%E6%89%AF%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="汇编语言入门九：总结与后续（闲扯）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B9%9D%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E5%90%8E%E7%BB%AD%EF%BC%88%E9%97%B2%E6%89%AF%EF%BC%89/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/31/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E4%B9%9D%EF%BC%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E5%90%8E%E7%BB%AD%EF%BC%88%E9%97%B2%E6%89%AF%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://zhuanlan.zhihu.com/p/24424432" target="_blank" rel="noopener" title="原文链接">原文链接</a></p>
<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>前面扯了一些个汇编语言的内容，想必读者也应该有了大致的了解。笔者比打算写全面的汇编相关的内容，毕竟目前已经有不少相关的资料了。本入门系列的目的就在于：入门。</p>
<h2 id="完成了入门的任务，入门系列就暂告一段落了。在此，先来对前面提及的内容做一些回顾。前面说到的各项内容大概涉及："><a href="#完成了入门的任务，入门系列就暂告一段落了。在此，先来对前面提及的内容做一些回顾。前面说到的各项内容大概涉及：" class="headerlink" title="完成了入门的任务，入门系列就暂告一段落了。在此，先来对前面提及的内容做一些回顾。前面说到的各项内容大概涉及："></a>完成了入门的任务，入门系列就暂告一段落了。在此，先来对前面提及的内容做一些回顾。前面说到的各项内容大概涉及：</h2><ul>
<li>环境配置</li>
<li>寄存器</li>
<li>内存访问</li>
<li>流程控制</li>
<li>函数调用</li>
<li>反汇编</li>
<li>调试</li>
</ul>
<p>我想，学习汇编中比较容易犯难的几个环节，大致也都覆盖到了。并且教程中也提供了可运行的实例，供读者在学习之后用于验证。</p>
<h3 id="学汇编到底学什么"><a href="#学汇编到底学什么" class="headerlink" title="学汇编到底学什么"></a>学汇编到底学什么</h3><p>我想，很多新手在了解汇编语言的时候，难免会遇到各种蛋疼的问题。大致有这样一些情况：</p>
<p>有参考书，虽然书中的知识体系全面，但是内容多却晦涩难懂<br>内容老旧，一时找不到合适的试验环境来验证，仅仅停留于书本，缺乏强烈直观的感受<br>各种规范各种环境乱七八糟不统一，讨论汇编时太依赖于特定环境，进一步加大了动手验证的难度<br>这无疑是给学习者泼来一盆冷水，本来只有3分的热情被灭掉了余下0.3分。</p>
<p>其实学习汇编语言，和学习C语言就有所不同了。你不用想着以后用汇编进行编程，学习汇编语言的首要目标是理解CPU运行程序的时候到底在干什么，你编写的C程序或者其他什么代码在CPU的眼里到底是个什么玩意儿，你能够通过汇编去分析程序的行为，解释一些高级语言下无法解释的现象，等等，才是学习的目标。</p>
<p>也就是说，学习汇编语言，应该抱着理解的目标去学习，理解透彻便足矣，无需做到能够流利地用汇编进行编程。</p>
<p>即便如此，笔者前面所述的各方面入门内容也仅仅是入门。不同人有不同的学习历程、只是背景，笔者很难保证自己觉得足够的入门教程，能够让每个读者都刚好受用。鉴于此，笔者将列出在了解了入门内容后需要关心的内容。</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>前面也有提到，学习汇编所需要侧重的是理解，而非熟练地编代码。汇编语言更像是一套理论知识，用于分析和解释程序在足够底层时的行为和现象。</p>
<p>与其说学习汇编，不如说是揭开高级语言的面纱，深入到更底层的地方去了解计算机原理，靠近计算机程序的本质。深入理解底层原理，有助于建立对计算机更系统的更深入的认识，面对一些看似诡异的问题时能心中有数，有方法有思路有理据去分析和解决。</p>
<p>要做到这一点，是需要循序渐进慢慢学习的。读者可在后续关注这样一些内容：</p>
<h3 id="继续学习汇编语言"><a href="#继续学习汇编语言" class="headerlink" title="继续学习汇编语言"></a>继续学习汇编语言</h3><p>笔者前面所述的入门内容只能保证覆盖了核心内容，并未覆盖到汇编语言相关的方方面面。读者至少要让自己学习汇编知识覆盖面达到足以形成图灵完备的最小集合。</p>
<p>可以从分析高级语言（比如C）去学习汇编语言，如前面所述的反汇编。关注这样一些内容：</p>
<ul>
<li>指令</li>
<li>寄存器</li>
<li>内存访问</li>
<li>条件跳转</li>
<li>堆栈</li>
<li>程序状态</li>
</ul>
<p>这些概念不仅在x86体系下，在ARM或是MIPS体系下也适用。仅仅是在不同环境下有不同的思路，有不同的表现形式，但是，核心的概念都是一致的。</p>
<h3 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h3><p>到这里，便是让你对所有计算机系统的认识有一个大统一。上面说到不同CPU平台下都有相当的共性。组成原理便是对所有计算机系统的大统一，不同平台只是在根据自己的目标特点和偏好在对计算机原理进行应用而已。</p>
<p>组成原理会告诉你，计算机在电路这个层面的本质是什么。</p>
<p>有了上述的汇编、组成原理的认识，同时也还应该去了解计算机操作系统。这里所谓的操作系统是指站在专业的角度，讨论操作系统本质上是在做什么事情，解决什么问题。</p>
<p>这些基础知识将会作为今后进一步学习计算机的坚实基础，基于对计算机、对操作系统的理解，计算机中的一切都将不再神秘，其本质都不过如此，基于自己所学去分析、去理解即可。</p>
<h3 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h3><p>笔者在学习的过程中，也尝试过总结适合自己的方法，在此也谈一谈自己学习的方式。</p>
<p>虽然微积分揭示了自然现象和数学之间很多本质的东西，但是让一个小学生直接学习的话，难免会困难重重。这里的问题并不在于知识体系不够全面、不够严谨，而在于学习者对微积分没有基本的感性认识，根本不知道是个啥玩意儿（计算期末考试分数的新方法？），即使记住了这些公式和证明，但自身难以去自行演绎，这其实是无效的学习。</p>
<p>所以，借助此例，结合自身经历，笔者认为学习的时候应该先关注下面一些方面：</p>
<h3 id="寻求感性认识"><a href="#寻求感性认识" class="headerlink" title="寻求感性认识"></a>寻求感性认识</h3><p>学习一个陌生的东西，我都会尝试先寻求一个感性的认识，感性认识达到什么程度呢？就是做到自己能够用一些简洁的白话，把自己接下来要学习的东西到底是什么玩意儿，给解释清楚，最好能够做到让不明白的人也能听明白。</p>
<p>比如什么是计算机？你能想到的就是你面对的那一台电脑，里面有丰富的的软件，可以做很多有趣的事情。</p>
<h3 id="了解边界"><a href="#了解边界" class="headerlink" title="了解边界"></a>了解边界</h3><p>笔者所谓的边界，即接下来要学习的这个东西，能做什么，不能做什么。学习之前明白这一点也非常重要，基于此，便能有一个清晰的目标，对学习后会面对的问题也有一定的底。</p>
<p>比如计算机是无法直接驱动一个火箭上天的，但是能够对航天器的行为进行控制。</p>
<h3 id="让学习可验证"><a href="#让学习可验证" class="headerlink" title="让学习可验证"></a>让学习可验证</h3><p>学习过程中自己会思考，会想出很多问题，但是这些问题并非都能从书中找到答案。而在学习过程中要刻意的去养成对知识、对自己的新想法进行验证的习惯。这里面大致是这样的过程：</p>
<p>脑子里冒出来一个想法，可能是疑惑，可能是矛盾<br>猜想一种最可能的情况来解释<br>通过实践去验证自己的猜想<br>总结、回顾（验证后的结果不能解释自己的猜想，会去重新猜）<br>这里的动手验证不是说真的得去拿个锤子砸钉子，而是说这里的分析、思考、试验、演绎等过程需要落到实处，而不是看到了某个模糊的说法，就这样糊弄过去了。</p>
<p>学习时尽量去给自己建立一个足以验证自己所学的环境，或者至少保证自己有了问题知道怎么样去验证。这将是支撑持续而有效学习的可能性和动力的重要基础。</p>
<p>比如通过编程、调试这样的手段去面对语言学习时的各种不解、各种矛盾的问题。通过编程看到结果、进行试验，透过调试去分析、简化学习中的稳题。有搞不明白的代码了，就赶紧编个程序来验证，尽量根据自己的想法把程序写出花儿来，看看到底都发生了些什么。</p>
<h3 id="Over"><a href="#Over" class="headerlink" title="Over"></a>Over</h3><p>关于汇编的专门介绍到此就告一段落了，后续笔者将会出更多相关话题的内容，不过内容的深度和难度都会有所上升，也可能更加抽象。</p>
<p>文中若有疏漏或不当之处，欢迎指正。</p>
<p>编辑于 2016-12-17</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="ljxhb@126.com"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ljxhb@126.com</p>
  <div class="site-description" itemprop="description">记录生活的点点滴滴</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/nonlee" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;nonlee" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ljxhb@126.com" title="E-Mail &amp;rarr; mailto:ljxhb@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.nonlee.com/" title="https:&#x2F;&#x2F;blog.nonlee.com&#x2F;" rel="noopener" target="_blank">github备份</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">蜀ICP备19024594号 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ljxhb@126.com</span>

<!-- 访问统计 速度有点慢，注释-->
<!--
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="site-uv">&nbsp;
      <i class="fa fa-eye"></i>
      访问次数:<span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
    </span>
-->
</div>


        










  <script>
    var _mtac = {};
    (function() {
      var mta = document.createElement("script");
      mta.src = "https://pingjs.qq.com/h5/stats.js";
      mta.setAttribute("name", "MTAH5");
      mta.setAttribute("sid", "500701487");
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(mta, s);
    })();
  </script>


        
      </div>
    </footer>
  </div>

  
  <script size="120" alpha="0.15" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
<script src="/js/utils.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  






  <script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'RTSsapWxOUV1SKIKT16wFPtB-gzGzoHsz',
    appKey: 'H9bCb63qalO3BOe07X7SCtHA',
    placeholder: "说两句吧...",
    avatar: 'identicon',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
